# 比较

1. java接口（interface）只能定义抽象方法，`不能提供具体实现`。java抽象类（abstract class）可以为某些方法`提供具体实现`。

   > **abstract class更容易扩展**
   >
   > 向abstract class加入一个具体实现的方法，它的全部子类可以获得这个方法。
   >
   > 但对于interface来说无法实现。interface加入一个新方法后实现类全部都不能通过编译，需要再实现新加入的方法。

2. 由于java语言的单继承性，interface的类型定义效能好于abstract class。

> interface:任何一个实现了一个Java接口所规定的方法的类都可以具有这个接口的类型，而一个类可以实现任意多个Java接口，从而这个类就有了多种类型。
>
> abstract class:使用抽象类，那么继承这个抽象类的子类类型就比较单一，因为子类只能单继承抽象类；而子类能够同时实现多个接口，因为类型就比较多。接口和抽象类都可以定义对象，但是只能用他们的具体实现类来进行实例化。

---

# 总结

1. Java接口是定义混合类型的理想工具，混合类表明一个类不仅仅具有某个主类型的行为，而且具有其他的次要行为。

2. **缺省适配模式**

   > 声明类型的工作仍然由Java接口承担，但是同时给出一个Java 抽象类，且实现了这个接口，而其他同属于这个抽象类型的具体类可以选择实现这个Java接口，也可以选择继承这个抽象类，***也就是说在层次结构中，Java 接口在最上面，然后紧跟着抽象类***，这下两个的最大优点都能发挥到极至了。
   >
   > 在Java语言API中用了这种模式，而且全都遵循一定的命名规范：Abstract ＋接口名。（**A extends AbstractB implements interfaceC**，那么A即可以选择实现(@Override)接口interfaceC中的方法，也可以选择不实现；A即可以选择实现(@Override)抽象类AbstractB中的方法，也可以选择不实现）

---

# 实例

下面给出一个具体的接口Action，代码如下所示：

```java
package org.springframework.webflow.execution;
public interface Action {
	public Event execute(RequestContext context) throws Exception;
}
```

在这个接口中，定义了一个没有具体实现的方法，方法名叫做execute()，返回类型是Event。如前面第一条所述，接口中的方法都是没有实现的。这些方法的具体实现是在实现(implements)这个接口的类中给出的。
再来看一个实现Action接口的抽象类AbstractAction，代码如下。

```java
package org.springframework.webflow.action;
 
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.BeanInitializationException;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.util.ClassUtils;
import org.springframework.webflow.core.collection.AttributeMap;
import org.springframework.webflow.execution.Action;
import org.springframework.webflow.execution.Event;
import org.springframework.webflow.execution.RequestContext;
 
public abstract class AbstractAction implements Action, InitializingBean {
 
	protected final Log logger = LogFactory.getLog(getClass());
 
	public EventFactorySupport getEventFactorySupport() {
		return new EventFactorySupport();
	}
 
	public void afterPropertiesSet() throws Exception {
		try {
			initAction();
		} catch (Exception ex) {
			throw new BeanInitializationException("Initialization of this Action failed: " + ex.getMessage(), ex);
		}
	}
 
	protected void initAction() throws Exception {
	}
 
	protected Event success() {
		return getEventFactorySupport().success(this);
	}
 
	protected Event success(Object result) {
		return getEventFactorySupport().success(this, result);
	}
 
	protected Event error() {
		return getEventFactorySupport().error(this);
	}
 
	protected Event error(Exception e) {
		return getEventFactorySupport().error(this, e);
	}
 
	protected Event yes() {
		return getEventFactorySupport().yes(this);
	}
 
	protected Event no() {
		return getEventFactorySupport().no(this);
	}
 
	protected Event result(boolean booleanResult) {
		return getEventFactorySupport().event(this, booleanResult);
	}
 
	protected Event result(String eventId) {
		return getEventFactorySupport().event(this, eventId);
	}
 
	protected Event result(String eventId, AttributeMap resultAttributes) {
		return getEventFactorySupport().event(this, eventId, resultAttributes);
	}
 
	protected Event result(String eventId, String resultAttributeName, Object resultAttributeValue) {
		return getEventFactorySupport().event(this, eventId, resultAttributeName, resultAttributeValue);
	}
 
	public final Event execute(RequestContext context) throws Exception {
		Event result = doPreExecute(context);
		if (result == null) {
			result = doExecute(context);
			doPostExecute(context);
		} else {
			if (logger.isInfoEnabled()) {
				logger.info("Action execution disallowed; pre-execution result is '" + result.getId() + "'");
			}
		}
		return result;
	}
 
	protected String getActionNameForLogging() {
		return ClassUtils.getShortName(getClass());
	}
 
	protected Event doPreExecute(RequestContext context) throws Exception {
		return null;
	}
 
	//抽象方法
	protected abstract Event doExecute(RequestContext context) throws Exception;
 
	protected void doPostExecute(RequestContext context) throws Exception {
	}
}
```

在抽象类AbstractAction中，既有具体实现的方法，又有没有具体实现的抽象方法

```java
	//抽象方法
	protected abstract Event doExecute(RequestContext context) throws Exception;
```

需要注意的是在抽象类中，如果方法没有具体实现（就是方法后面 **没有{}**），那么必须加上abstract来声明这个方法，而接口中不需要使用abstract来声明 **（抽象类之所以被称为抽象类，就是因为它包含有抽象方法。含有抽象方法的类叫做抽象类）**。

---

# [参考](https://blog.csdn.net/xw13106209/article/details/6923556)

